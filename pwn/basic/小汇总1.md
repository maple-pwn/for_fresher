# 总结1

by Maple

写了这么久的题了，但是看到题还是一头雾水，完全在瞎碰，写个小总结，系统整理整理吧

**从保护开始**

## Canary

就是在栈底放一个随机数，如果缓冲区变量溢出，那么这个随机数也会被篡改，当函数结束的时候会对这个随机数检查，如果发现这个随机数变了，就会执行`_stack_chk_fail`函数终止程序

从汇编角度看：函数序言会向保存调用函数的栈底指针，然后设置被调用函数自身的栈底指针，最后分配栈空间，这3条汇编指令标志着一个经典的函数序言

>  比如`buuctf`中的`bjdctf_2020_babyrop2`，有开启Canary保护，就存在这样的代码
>
> ```assembly
> mov     rbp, rsp
> sub     rsp, 20h
> mov     rax, fs:28h
> ```

但是Canary的非即时检测就留下了一定的操作空间：

只要可以让Canary在函数未结束前泄露出来，构造payload时在它本应在的位置写上Canary就可以了

所以问题就变为了如何泄露出来Canary，了解一下Canary随机值的特点

（或者修改指向`_stack_chk_fail`的地址，让函数走向后门函数）

- 一般Canary会在`ebp-0x8`处存储，

- 其最低位设置为`\x00`

  >  这里本意时为了保证字符串可以被`\x00`截断，从而保护其它字节信息

### 绕过思路

#### 覆盖截断获取随机值

先填充缓冲区变量到Canary的最低字节，然后获取泄露的Canary，最后根据Canary的值填充`rbp-0x8`的位置，此后调用函数栈指针可以随意覆盖

假设有一个题目这样布局

```c
  char buf[24]; // [rsp+0h] [rbp-20h] BYREF
  unsigned __int64 v2; // [rsp+18h] [rbp-8h]
```

可以这样覆盖并泄露

```python
off_set = b'A'*(0x20-0x8)
p.sendline(off_set)
result = p.recvuntil(b'a'*(0x20-0x8)+b'\n')
canary = u64(b'\x00'+p.recv(7))
```

#### 格式化字符串直接泄露