# PolarCTF2024冬季个人挑战赛 CRYPTO方向 RSA共模攻击

by zijeff

题目也说了这道题考察的是RSA共模攻击，就是在加密同一段明文m时，使用了相同的n，只是使用的e不相同。

对于这种形式的RSA加密，我们可以通过数学推导证明即使不用私钥d，我们也可以从密文c中得到明文m。

对于这道题我们发现e1和e2互素，即有：
$$
gcd(e_1,e_2)=1
$$
证明如下：

对于同一段密文m，我们选取两个不同的公钥指数，记为e1和e2，那么加密后得到两段密文分别记为c1和c2。
$$
c_1=m^{e_1} \mod n
$$

$$
c_2=m^{e_2} \mod n
$$

根据扩展欧几里得算法，我们有如下命题成立。

对于e1和e2这两个数，一定存在着两个整数记为s1和s2，使得下面这个式子成立：
$$
e_1s_1+e_2s_2=gcd(e_1,e_2)=1
$$
所以根据模运算的性质，做一下代数变形，我们就可以得到以下的式子：
$$
(c_1^{s_1}c_2^{s_2})\mod n=(m^{e_1s_1+e_2s_2})\mod n
$$
如果不是很理解，也可以根据带余除法的定义推导一下。比如设有如下式子：
$$
m^{e_1}=k_1n+c_1
$$

$$
m^{e_2}=k_2n+c_2
$$

将其全部带入原式，然后展开计算，我就不详细写了。

接下来我们处理一下等式的右边：
$$
(m^{e_1s_1+e_2s_2})\mod n=m\mod n
$$
又因为RSA的解密公式为：
$$
m=c^d\mod n
$$
得到：
$$
m\in[0,n-1]
$$
所以等式右边对m取模相当于没起到任何作用。

经过以上的分析，解决问题的关键在于求解s1和s2的值，那就要利用扩展欧几里得算法了。

而sagemath中刚好有对应的求解函数，所以我们可以利用以下代码直接求解。

(当然，也可以自己写个程序算一算)

```python
e1=2333
e2=23333
gcd,s1,s2=xgcd(e1,e2)
print(e1)
print(e2)
```

得到：
$$
s_1=-7781
$$

$$
s_2=778
$$

但在模运算下算负数次幂时，我们先要找到底数的乘法逆元，将负数次幂转化为正数次幂。
$$
c_1c_3\equiv1\mod n
$$
这就是解题脚本的思路了，答案也就是flag{6480a3bf-82e2-44e0-9c32-b6a0da8ec46d}
