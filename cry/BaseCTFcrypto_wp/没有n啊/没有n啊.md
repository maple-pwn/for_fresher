# BaseCTF CPYPTO方向 没有n啊

by zijeff

打开题目附件后，仍然是常见的RSA加密。

题目也给出了突破口，就是x的值和得到x的过程：

```python
x=pow(n,e,c)
#x = 40635864473997460751766935373772107585133301579524000836637683731949939348171187931595274511243052505604832873086269554842194695737052043633079044688826020656068356561856848814530947955429343483847291398607359454851926470168457852479044154798114087493843073091985855839008222762224952503563764527380033064437
```

结合RSA加密的过程，我们不难发现，得到x的过程就是RSA加密：
$$
x = n^e \mod c
$$
但是我们要注意，在正常的RSA加密中，c是会小于n的，即：
$$
c<n
$$
因为RSA加密是计算下面这个式子：
$$
c = m^e \mod n
$$
所以很容易得出，c小于n，因此我们不妨设：
$$
n=c+a
$$
又有：
$$
x=n^e \mod c
$$
化简得：
$$
x=a^e \mod c
$$
求解出a，即可反向推出n的值，再结合题目给出的d值，即可解决问题。

要求解a的值，我们需要求解满足如下等式的d'的值：
$$
ed' \equiv 1 \mod \phi(c)
$$
首先我们可以求解phi(c)的值，结合欧拉函数的性质，只要我们可以将c完全分解就可以解决。

然后求解d'的值从而解出a来，这道题的思路就是这样。

注：不要忘了加个n，不要忘了加个n，不要忘了加个n。

小声bb：才不是某个人忘了加。